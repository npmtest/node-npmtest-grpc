{"/home/travis/build/npmtest/node-npmtest-grpc/test.js":"/* istanbul instrument in package npmtest_grpc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grpc/lib.npmtest_grpc.js":"/* istanbul instrument in package npmtest_grpc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_grpc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_grpc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-grpc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-grpc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_grpc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_grpc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_grpc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_grpc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_grpc.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_grpc.__dirname + '/lib.npmtest_grpc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/src/node/index.js":"/*\n *\n * Copyright 2015, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n'use strict';\n\nvar path = require('path');\nvar fs = require('fs');\n\nvar SSL_ROOTS_PATH = path.resolve(__dirname, '..', '..', 'etc', 'roots.pem');\n\nvar _ = require('lodash');\n\nvar ProtoBuf = require('protobufjs');\n\nvar client = require('./src/client.js');\n\nvar server = require('./src/server.js');\n\nvar common = require('./src/common.js');\n\nvar Metadata = require('./src/metadata.js');\n\nvar grpc = require('./src/grpc_extension');\n\ngrpc.setDefaultRootsPem(fs.readFileSync(SSL_ROOTS_PATH, 'ascii'));\n\n/**\n * Load a gRPC object from an existing ProtoBuf.Reflect object.\n * @param {ProtoBuf.Reflect.Namespace} value The ProtoBuf object to load.\n * @param {Object=} options Options to apply to the loaded object\n * @return {Object<string, *>} The resulting gRPC object\n */\nexports.loadObject = function loadObject(value, options) {\n  var result = {};\n  if (value.className === 'Namespace') {\n    _.each(value.children, function(child) {\n      result[child.name] = loadObject(child, options);\n    });\n    return result;\n  } else if (value.className === 'Service') {\n    return client.makeProtobufClientConstructor(value, options);\n  } else if (value.className === 'Message' || value.className === 'Enum') {\n    return value.build();\n  } else {\n    return value;\n  }\n};\n\nvar loadObject = exports.loadObject;\n\n/**\n * Load a gRPC object from a .proto file. The options object can provide the\n * following options:\n * - convertFieldsToCamelCase: Loads this file with that option on protobuf.js\n *   set as specified. See\n *   https://github.com/dcodeIO/protobuf.js/wiki/Advanced-options for details\n * - binaryAsBase64: deserialize bytes values as base64 strings instead of\n *   Buffers. Defaults to false\n * - longsAsStrings: deserialize long values as strings instead of objects.\n *   Defaults to true\n * - deprecatedArgumentOrder: Use the beta method argument order for client\n *   methods, with optional arguments after the callback. Defaults to false.\n *   This option is only a temporary stopgap measure to smooth an API breakage.\n *   It is deprecated, and new code should not use it.\n * @param {string|{root: string, file: string}} filename The file to load\n * @param {string=} format The file format to expect. Must be either 'proto' or\n *     'json'. Defaults to 'proto'\n * @param {Object=} options Options to apply to the loaded file\n * @return {Object<string, *>} The resulting gRPC object\n */\nexports.load = function load(filename, format, options) {\n  if (!format) {\n    format = 'proto';\n  }\n  var convertFieldsToCamelCaseOriginal = ProtoBuf.convertFieldsToCamelCase;\n  if(options && options.hasOwnProperty('convertFieldsToCamelCase')) {\n    ProtoBuf.convertFieldsToCamelCase = options.convertFieldsToCamelCase;\n  }\n  var builder;\n  try {\n    switch(format) {\n      case 'proto':\n      builder = ProtoBuf.loadProtoFile(filename);\n      break;\n      case 'json':\n      builder = ProtoBuf.loadJsonFile(filename);\n      break;\n      default:\n      throw new Error('Unrecognized format \"' + format + '\"');\n    }\n  } finally {\n    ProtoBuf.convertFieldsToCamelCase = convertFieldsToCamelCaseOriginal;\n  }\n  return loadObject(builder.ns, options);\n};\n\nvar log_template = _.template(\n    '{severity} {timestamp}\\t{file}:{line}]\\t{message}',\n    {interpolate: /{([\\s\\S]+?)}/g});\n\n/**\n * Sets the logger function for the gRPC module. For debugging purposes, the C\n * core will log synchronously directly to stdout unless this function is\n * called. Note: the output format here is intended to be informational, and\n * is not guaranteed to stay the same in the future.\n * Logs will be directed to logger.error.\n * @param {Console} logger A Console-like object.\n */\nexports.setLogger = function setLogger(logger) {\n  common.logger = logger;\n  grpc.setDefaultLoggerCallback(function(file, line, severity,\n                                         message, timestamp) {\n    logger.error(log_template({\n      file: path.basename(file),\n      line: line,\n      severity: severity,\n      message: message,\n      timestamp: timestamp.toISOString()\n    }));\n  });\n};\n\n/**\n * Sets the logger verbosity for gRPC module logging. The options are members\n * of the grpc.logVerbosity map.\n * @param {Number} verbosity The minimum severity to log\n */\nexports.setLogVerbosity = function setLogVerbosity(verbosity) {\n  common.logVerbosity = verbosity;\n  grpc.setLogVerbosity(verbosity);\n};\n\n/**\n * @see module:src/server.Server\n */\nexports.Server = server.Server;\n\n/**\n * @see module:src/metadata\n */\nexports.Metadata = Metadata;\n\n/**\n * Status name to code number mapping\n */\nexports.status = grpc.status;\n\n/**\n * Propagate flag name to number mapping\n */\nexports.propagate = grpc.propagate;\n\n/**\n * Call error name to code number mapping\n */\nexports.callError = grpc.callError;\n\n/**\n * Write flag name to code number mapping\n */\nexports.writeFlags = grpc.writeFlags;\n\n/**\n * Log verbosity setting name to code number mapping\n */\nexports.logVerbosity = grpc.logVerbosity;\n\n/**\n * Credentials factories\n */\nexports.credentials = require('./src/credentials.js');\n\n/**\n * ServerCredentials factories\n */\nexports.ServerCredentials = grpc.ServerCredentials;\n\n/**\n * @see module:src/client.makeClientConstructor\n */\nexports.makeGenericClientConstructor = client.makeClientConstructor;\n\n/**\n * @see module:src/client.getClientChannel\n */\nexports.getClientChannel = client.getClientChannel;\n\n/**\n * @see module:src/client.waitForClientReady\n */\nexports.waitForClientReady = client.waitForClientReady;\n\nexports.closeClient = function closeClient(client_obj) {\n  client.getClientChannel(client_obj).close();\n};\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/src/node/src/client.js":"/*\n *\n * Copyright 2015, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/**\n * Client module\n *\n * This module contains the factory method for creating Client classes, and the\n * method calling code for all types of methods.\n *\n * For example, to create a client and call a method on it:\n *\n * var proto_obj = grpc.load(proto_file_path);\n * var Client = proto_obj.package.subpackage.ServiceName;\n * var client = new Client(server_address, client_credentials);\n * var call = client.unaryMethod(arguments, callback);\n *\n * @module\n */\n\n'use strict';\n\nvar _ = require('lodash');\nvar arguejs = require('arguejs');\n\nvar grpc = require('./grpc_extension');\n\nvar common = require('./common');\n\nvar Metadata = require('./metadata');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar stream = require('stream');\n\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar Duplex = stream.Duplex;\nvar util = require('util');\nvar version = require('../../../package.json').version;\n\nutil.inherits(ClientWritableStream, Writable);\n\n/**\n * A stream that the client can write to. Used for calls that are streaming from\n * the client side.\n * @constructor\n * @param {grpc.Call} call The call object to send data with\n * @param {function(*):Buffer=} serialize Serialization function for writes.\n */\nfunction ClientWritableStream(call, serialize) {\n  Writable.call(this, {objectMode: true});\n  this.call = call;\n  this.serialize = common.wrapIgnoreNull(serialize);\n  this.on('finish', function() {\n    var batch = {};\n    batch[grpc.opType.SEND_CLOSE_FROM_CLIENT] = true;\n    call.startBatch(batch, function() {});\n  });\n}\n\n/**\n * Attempt to write the given chunk. Calls the callback when done. This is an\n * implementation of a method needed for implementing stream.Writable.\n * @access private\n * @param {Buffer} chunk The chunk to write\n * @param {string} encoding Used to pass write flags\n * @param {function(Error=)} callback Called when the write is complete\n */\nfunction _write(chunk, encoding, callback) {\n  /* jshint validthis: true */\n  var batch = {};\n  var message;\n  try {\n    message = this.serialize(chunk);\n  } catch (e) {\n    /* Sending this error to the server and emitting it immediately on the\n       client may put the call in a slightly weird state on the client side,\n       but passing an object that causes a serialization failure is a misuse\n       of the API anyway, so that's OK. The primary purpose here is to give the\n       programmer a useful error and to stop the stream properly */\n    this.call.cancelWithStatus(grpc.status.INTERNAL, 'Serialization failure');\n    callback(e);\n  }\n  if (_.isFinite(encoding)) {\n    /* Attach the encoding if it is a finite number. This is the closest we\n     * can get to checking that it is valid flags */\n    message.grpcWriteFlags = encoding;\n  }\n  batch[grpc.opType.SEND_MESSAGE] = message;\n  this.call.startBatch(batch, function(err, event) {\n    if (err) {\n      // Something has gone wrong. Stop writing by failing to call callback\n      return;\n    }\n    callback();\n  });\n}\n\nClientWritableStream.prototype._write = _write;\n\nutil.inherits(ClientReadableStream, Readable);\n\n/**\n * A stream that the client can read from. Used for calls that are streaming\n * from the server side.\n * @constructor\n * @param {grpc.Call} call The call object to read data with\n * @param {function(Buffer):*=} deserialize Deserialization function for reads\n */\nfunction ClientReadableStream(call, deserialize) {\n  Readable.call(this, {objectMode: true});\n  this.call = call;\n  this.finished = false;\n  this.reading = false;\n  this.deserialize = common.wrapIgnoreNull(deserialize);\n  /* Status generated from reading messages from the server. Overrides the\n   * status from the server if not OK */\n  this.read_status = null;\n  /* Status received from the server. */\n  this.received_status = null;\n}\n\n/**\n * Called when all messages from the server have been processed. The status\n * parameter indicates that the call should end with that status. status\n * defaults to OK if not provided.\n * @param {Object!} status The status that the call should end with\n */\nfunction _readsDone(status) {\n  /* jshint validthis: true */\n  if (!status) {\n    status = {code: grpc.status.OK, details: 'OK'};\n  }\n  if (status.code !== grpc.status.OK) {\n    this.call.cancelWithStatus(status.code, status.details);\n  }\n  this.finished = true;\n  this.read_status = status;\n  this._emitStatusIfDone();\n}\n\nClientReadableStream.prototype._readsDone = _readsDone;\n\n/**\n * Called to indicate that we have received a status from the server.\n */\nfunction _receiveStatus(status) {\n  /* jshint validthis: true */\n  this.received_status = status;\n  this._emitStatusIfDone();\n}\n\nClientReadableStream.prototype._receiveStatus = _receiveStatus;\n\n/**\n * If we have both processed all incoming messages and received the status from\n * the server, emit the status. Otherwise, do nothing.\n */\nfunction _emitStatusIfDone() {\n  /* jshint validthis: true */\n  var status;\n  if (this.read_status && this.received_status) {\n    if (this.read_status.code !== grpc.status.OK) {\n      status = this.read_status;\n    } else {\n      status = this.received_status;\n    }\n    if (status.code === grpc.status.OK) {\n      this.push(null);\n    } else {\n      var error = new Error(status.details);\n      error.code = status.code;\n      error.metadata = status.metadata;\n      this.emit('error', error);\n    }\n    this.emit('status', status);\n  }\n}\n\nClientReadableStream.prototype._emitStatusIfDone = _emitStatusIfDone;\n\n/**\n * Read the next object from the stream.\n * @access private\n * @param {*} size Ignored because we use objectMode=true\n */\nfunction _read(size) {\n  /* jshint validthis: true */\n  var self = this;\n  /**\n   * Callback to be called when a READ event is received. Pushes the data onto\n   * the read queue and starts reading again if applicable\n   * @param {grpc.Event} event READ event object\n   */\n  function readCallback(err, event) {\n    if (err) {\n      // Something has gone wrong. Stop reading and wait for status\n      self.finished = true;\n      self._readsDone();\n      return;\n    }\n    var data = event.read;\n    var deserialized;\n    try {\n      deserialized = self.deserialize(data);\n    } catch (e) {\n      self._readsDone({code: grpc.status.INTERNAL,\n                       details: 'Failed to parse server response'});\n      return;\n    }\n    if (data === null) {\n      self._readsDone();\n      return;\n    }\n    if (self.push(deserialized) && data !== null) {\n      var read_batch = {};\n      read_batch[grpc.opType.RECV_MESSAGE] = true;\n      self.call.startBatch(read_batch, readCallback);\n    } else {\n      self.reading = false;\n    }\n  }\n  if (self.finished) {\n    self.push(null);\n  } else {\n    if (!self.reading) {\n      self.reading = true;\n      var read_batch = {};\n      read_batch[grpc.opType.RECV_MESSAGE] = true;\n      self.call.startBatch(read_batch, readCallback);\n    }\n  }\n}\n\nClientReadableStream.prototype._read = _read;\n\nutil.inherits(ClientDuplexStream, Duplex);\n\n/**\n * A stream that the client can read from or write to. Used for calls with\n * duplex streaming.\n * @constructor\n * @param {grpc.Call} call Call object to proxy\n * @param {function(*):Buffer=} serialize Serialization function for requests\n * @param {function(Buffer):*=} deserialize Deserialization function for\n *     responses\n */\nfunction ClientDuplexStream(call, serialize, deserialize) {\n  Duplex.call(this, {objectMode: true});\n  this.serialize = common.wrapIgnoreNull(serialize);\n  this.deserialize = common.wrapIgnoreNull(deserialize);\n  this.call = call;\n  /* Status generated from reading messages from the server. Overrides the\n   * status from the server if not OK */\n  this.read_status = null;\n  /* Status received from the server. */\n  this.received_status = null;\n  this.on('finish', function() {\n    var batch = {};\n    batch[grpc.opType.SEND_CLOSE_FROM_CLIENT] = true;\n    call.startBatch(batch, function() {});\n  });\n}\n\nClientDuplexStream.prototype._readsDone = _readsDone;\nClientDuplexStream.prototype._receiveStatus = _receiveStatus;\nClientDuplexStream.prototype._emitStatusIfDone = _emitStatusIfDone;\nClientDuplexStream.prototype._read = _read;\nClientDuplexStream.prototype._write = _write;\n\n/**\n * Cancel the ongoing call\n */\nfunction cancel() {\n  /* jshint validthis: true */\n  this.call.cancel();\n}\n\nClientReadableStream.prototype.cancel = cancel;\nClientWritableStream.prototype.cancel = cancel;\nClientDuplexStream.prototype.cancel = cancel;\n\n/**\n * Get the endpoint this call/stream is connected to.\n * @return {string} The URI of the endpoint\n */\nfunction getPeer() {\n  /* jshint validthis: true */\n  return this.call.getPeer();\n}\n\nClientReadableStream.prototype.getPeer = getPeer;\nClientWritableStream.prototype.getPeer = getPeer;\nClientDuplexStream.prototype.getPeer = getPeer;\n\n/**\n * Get a call object built with the provided options. Keys for options are\n * 'deadline', which takes a date or number, and 'host', which takes a string\n * and overrides the hostname to connect to.\n * @param {Object} options Options map.\n */\nfunction getCall(channel, method, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = _.get(options, 'parent.call');\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n  var call = new grpc.Call(channel, method, deadline, host,\n                           parent, propagate_flags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\n/**\n * Get a function that can make unary requests to the specified method.\n * @param {string} method The name of the method to request\n * @param {function(*):Buffer} serialize The serialization function for inputs\n * @param {function(Buffer)} deserialize The deserialization function for\n *     outputs\n * @return {Function} makeUnaryRequest\n */\nfunction makeUnaryRequestFunction(method, serialize, deserialize) {\n  /**\n   * Make a unary request with this method on the given channel with the given\n   * argument, callback, etc.\n   * @this {Client} Client object. Must have a channel member.\n   * @param {*} argument The argument to the call. Should be serializable with\n   *     serialize\n   * @param {Metadata=} metadata Metadata to add to the call\n   * @param {Object=} options Options map\n   * @param {function(?Error, value=)} callback The callback to for when the\n   *     response is received\n   * @return {EventEmitter} An event emitter for stream related events\n   */\n  function makeUnaryRequest(argument, metadata, options, callback) {\n    /* jshint validthis: true */\n    /* While the arguments are listed in the function signature, those variables\n     * are not used directly. Instead, ArgueJS processes the arguments\n     * object. This allows for simple handling of optional arguments in the\n     * middle of the argument list, and also provides type checking. */\n    var args = arguejs({argument: null, metadata: [Metadata, new Metadata()],\n                        options: [Object], callback: Function}, arguments);\n    var emitter = new EventEmitter();\n    var call = getCall(this.$channel, method, args.options);\n    metadata = args.metadata.clone();\n    emitter.cancel = function cancel() {\n      call.cancel();\n    };\n    emitter.getPeer = function getPeer() {\n      return call.getPeer();\n    };\n    var client_batch = {};\n    var message = serialize(args.argument);\n    if (args.options) {\n      message.grpcWriteFlags = args.options.flags;\n    }\n\n    client_batch[grpc.opType.SEND_INITIAL_METADATA] =\n        metadata._getCoreRepresentation();\n    client_batch[grpc.opType.SEND_MESSAGE] = message;\n    client_batch[grpc.opType.SEND_CLOSE_FROM_CLIENT] = true;\n    client_batch[grpc.opType.RECV_INITIAL_METADATA] = true;\n    client_batch[grpc.opType.RECV_MESSAGE] = true;\n    client_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n    call.startBatch(client_batch, function(err, response) {\n      response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n      var status = response.status;\n      var error;\n      var deserialized;\n      emitter.emit('metadata', Metadata._fromCoreRepresentation(\n          response.metadata));\n      if (status.code === grpc.status.OK) {\n        if (err) {\n          // Got a batch error, but OK status. Something went wrong\n          args.callback(err);\n          return;\n        } else {\n          try {\n            deserialized = deserialize(response.read);\n          } catch (e) {\n            /* Change status to indicate bad server response. This will result\n             * in passing an error to the callback */\n            status = {\n              code: grpc.status.INTERNAL,\n              details: 'Failed to parse server response'\n            };\n          }\n        }\n      }\n      if (status.code !== grpc.status.OK) {\n        error = new Error(status.details);\n        error.code = status.code;\n        error.metadata = status.metadata;\n        args.callback(error);\n      } else {\n        args.callback(null, deserialized);\n      }\n      emitter.emit('status', status);\n    });\n    return emitter;\n  }\n  return makeUnaryRequest;\n}\n\n/**\n * Get a function that can make client stream requests to the specified method.\n * @param {string} method The name of the method to request\n * @param {function(*):Buffer} serialize The serialization function for inputs\n * @param {function(Buffer)} deserialize The deserialization function for\n *     outputs\n * @return {Function} makeClientStreamRequest\n */\nfunction makeClientStreamRequestFunction(method, serialize, deserialize) {\n  /**\n   * Make a client stream request with this method on the given channel with the\n   * given callback, etc.\n   * @this {Client} Client object. Must have a channel member.\n   * @param {Metadata=} metadata Array of metadata key/value pairs to add to the\n   *     call\n   * @param {Object=} options Options map\n   * @param {function(?Error, value=)} callback The callback to for when the\n   *     response is received\n   * @return {EventEmitter} An event emitter for stream related events\n   */\n  function makeClientStreamRequest(metadata, options, callback) {\n    /* jshint validthis: true */\n    /* While the arguments are listed in the function signature, those variables\n     * are not used directly. Instead, ArgueJS processes the arguments\n     * object. This allows for simple handling of optional arguments in the\n     * middle of the argument list, and also provides type checking. */\n    var args = arguejs({metadata: [Metadata, new Metadata()],\n                        options: [Object], callback: Function}, arguments);\n    var call = getCall(this.$channel, method, args.options);\n    metadata = args.metadata.clone();\n    var stream = new ClientWritableStream(call, serialize);\n    var metadata_batch = {};\n    metadata_batch[grpc.opType.SEND_INITIAL_METADATA] =\n        metadata._getCoreRepresentation();\n    metadata_batch[grpc.opType.RECV_INITIAL_METADATA] = true;\n    call.startBatch(metadata_batch, function(err, response) {\n      if (err) {\n        // The call has stopped for some reason. A non-OK status will arrive\n        // in the other batch.\n        return;\n      }\n      stream.emit('metadata', Metadata._fromCoreRepresentation(\n          response.metadata));\n    });\n    var client_batch = {};\n    client_batch[grpc.opType.RECV_MESSAGE] = true;\n    client_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n    call.startBatch(client_batch, function(err, response) {\n      response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n      var status = response.status;\n      var error;\n      var deserialized;\n      if (status.code === grpc.status.OK) {\n        if (err) {\n          // Got a batch error, but OK status. Something went wrong\n          args.callback(err);\n          return;\n        } else {\n          try {\n            deserialized = deserialize(response.read);\n          } catch (e) {\n            /* Change status to indicate bad server response. This will result\n             * in passing an error to the callback */\n            status = {\n              code: grpc.status.INTERNAL,\n              details: 'Failed to parse server response'\n            };\n          }\n        }\n      }\n      if (status.code !== grpc.status.OK) {\n        error = new Error(response.status.details);\n        error.code = status.code;\n        error.metadata = status.metadata;\n        args.callback(error);\n      } else {\n        args.callback(null, deserialized);\n      }\n      stream.emit('status', status);\n    });\n    return stream;\n  }\n  return makeClientStreamRequest;\n}\n\n/**\n * Get a function that can make server stream requests to the specified method.\n * @param {string} method The name of the method to request\n * @param {function(*):Buffer} serialize The serialization function for inputs\n * @param {function(Buffer)} deserialize The deserialization function for\n *     outputs\n * @return {Function} makeServerStreamRequest\n */\nfunction makeServerStreamRequestFunction(method, serialize, deserialize) {\n  /**\n   * Make a server stream request with this method on the given channel with the\n   * given argument, etc.\n   * @this {SurfaceClient} Client object. Must have a channel member.\n   * @param {*} argument The argument to the call. Should be serializable with\n   *     serialize\n   * @param {Metadata=} metadata Array of metadata key/value pairs to add to the\n   *     call\n   * @param {Object} options Options map\n   * @return {EventEmitter} An event emitter for stream related events\n   */\n  function makeServerStreamRequest(argument, metadata, options) {\n    /* jshint validthis: true */\n    /* While the arguments are listed in the function signature, those variables\n     * are not used directly. Instead, ArgueJS processes the arguments\n     * object. */\n    var args = arguejs({argument: null, metadata: [Metadata, new Metadata()],\n                        options: [Object]}, arguments);\n    var call = getCall(this.$channel, method, args.options);\n    metadata = args.metadata.clone();\n    var stream = new ClientReadableStream(call, deserialize);\n    var start_batch = {};\n    var message = serialize(args.argument);\n    if (args.options) {\n      message.grpcWriteFlags = args.options.flags;\n    }\n    start_batch[grpc.opType.SEND_INITIAL_METADATA] =\n        metadata._getCoreRepresentation();\n    start_batch[grpc.opType.RECV_INITIAL_METADATA] = true;\n    start_batch[grpc.opType.SEND_MESSAGE] = message;\n    start_batch[grpc.opType.SEND_CLOSE_FROM_CLIENT] = true;\n    call.startBatch(start_batch, function(err, response) {\n      if (err) {\n        // The call has stopped for some reason. A non-OK status will arrive\n        // in the other batch.\n        return;\n      }\n      stream.emit('metadata', Metadata._fromCoreRepresentation(\n          response.metadata));\n    });\n    var status_batch = {};\n    status_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n    call.startBatch(status_batch, function(err, response) {\n      if (err) {\n        stream.emit('error', err);\n        return;\n      }\n      response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n      stream._receiveStatus(response.status);\n    });\n    return stream;\n  }\n  return makeServerStreamRequest;\n}\n\n/**\n * Get a function that can make bidirectional stream requests to the specified\n * method.\n * @param {string} method The name of the method to request\n * @param {function(*):Buffer} serialize The serialization function for inputs\n * @param {function(Buffer)} deserialize The deserialization function for\n *     outputs\n * @return {Function} makeBidiStreamRequest\n */\nfunction makeBidiStreamRequestFunction(method, serialize, deserialize) {\n  /**\n   * Make a bidirectional stream request with this method on the given channel.\n   * @this {SurfaceClient} Client object. Must have a channel member.\n   * @param {Metadata=} metadata Array of metadata key/value pairs to add to the\n   *     call\n   * @param {Options} options Options map\n   * @return {EventEmitter} An event emitter for stream related events\n   */\n  function makeBidiStreamRequest(metadata, options) {\n    /* jshint validthis: true */\n    /* While the arguments are listed in the function signature, those variables\n     * are not used directly. Instead, ArgueJS processes the arguments\n     * object. */\n    var args = arguejs({metadata: [Metadata, new Metadata()],\n                        options: [Object]}, arguments);\n    var call = getCall(this.$channel, method, args.options);\n    metadata = args.metadata.clone();\n    var stream = new ClientDuplexStream(call, serialize, deserialize);\n    var start_batch = {};\n    start_batch[grpc.opType.SEND_INITIAL_METADATA] =\n        metadata._getCoreRepresentation();\n    start_batch[grpc.opType.RECV_INITIAL_METADATA] = true;\n    call.startBatch(start_batch, function(err, response) {\n      if (err) {\n        // The call has stopped for some reason. A non-OK status will arrive\n        // in the other batch.\n        return;\n      }\n      stream.emit('metadata', Metadata._fromCoreRepresentation(\n          response.metadata));\n    });\n    var status_batch = {};\n    status_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n    call.startBatch(status_batch, function(err, response) {\n      if (err) {\n        stream.emit('error', err);\n        return;\n      }\n      response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n      stream._receiveStatus(response.status);\n    });\n    return stream;\n  }\n  return makeBidiStreamRequest;\n}\n\n\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n */\nvar requester_makers = {\n  unary: makeUnaryRequestFunction,\n  server_stream: makeServerStreamRequestFunction,\n  client_stream: makeClientStreamRequestFunction,\n  bidi: makeBidiStreamRequestFunction\n};\n\nfunction getDefaultValues(metadata, options) {\n  var res = {};\n  res.metadata = metadata || new Metadata();\n  res.options = options || {};\n  return res;\n}\n\n/**\n * Map with wrappers for each type of requester function to make it use the old\n * argument order with optional arguments after the callback.\n */\nvar deprecated_request_wrap = {\n  unary: function(makeUnaryRequest) {\n    return function makeWrappedUnaryRequest(argument, callback,\n                                            metadata, options) {\n      /* jshint validthis: true */\n      var opt_args = getDefaultValues(metadata, metadata);\n      return makeUnaryRequest.call(this, argument, opt_args.metadata,\n                                   opt_args.options, callback);\n    };\n  },\n  client_stream: function(makeServerStreamRequest) {\n    return function makeWrappedClientStreamRequest(callback, metadata,\n                                                   options) {\n      /* jshint validthis: true */\n      var opt_args = getDefaultValues(metadata, options);\n      return makeServerStreamRequest.call(this, opt_args.metadata,\n                                          opt_args.options, callback);\n    };\n  },\n  server_stream: _.identity,\n  bidi: _.identity\n};\n\n/**\n * Creates a constructor for a client with the given methods. The methods object\n * maps method name to an object with the following keys:\n * path: The path on the server for accessing the method. For example, for\n *     protocol buffers, we use \"/service_name/method_name\"\n * requestStream: bool indicating whether the client sends a stream\n * resonseStream: bool indicating whether the server sends a stream\n * requestSerialize: function to serialize request objects\n * responseDeserialize: function to deserialize response objects\n * @param {Object} methods An object mapping method names to method attributes\n * @param {string} serviceName The fully qualified name of the service\n * @param {Object} class_options An options object. Currently only uses the key\n *     deprecatedArgumentOrder, a boolean that Indicates that the old argument\n *     order should be used for methods, with optional arguments at the end\n *     instead of the callback at the end. Defaults to false. This option is\n *     only a temporary stopgap measure to smooth an API breakage.\n *     It is deprecated, and new code should not use it.\n * @return {function(string, Object)} New client constructor\n */\nexports.makeClientConstructor = function(methods, serviceName,\n                                         class_options) {\n  if (!class_options) {\n    class_options = {};\n  }\n  /**\n   * Create a client with the given methods\n   * @constructor\n   * @param {string} address The address of the server to connect to\n   * @param {grpc.Credentials} credentials Credentials to use to connect\n   *     to the server\n   * @param {Object} options Options to pass to the underlying channel\n   */\n  function Client(address, credentials, options) {\n    if (!options) {\n      options = {};\n    }\n    /* Append the grpc-node user agent string after the application user agent\n     * string, and put the combination at the beginning of the user agent string\n     */\n    if (options['grpc.primary_user_agent']) {\n      options['grpc.primary_user_agent'] += ' ';\n    } else {\n      options['grpc.primary_user_agent'] = '';\n    }\n    options['grpc.primary_user_agent'] += 'grpc-node/' + version;\n    /* Private fields use $ as a prefix instead of _ because it is an invalid\n     * prefix of a method name */\n    this.$channel = new grpc.Channel(address, credentials, options);\n  }\n\n  _.each(methods, function(attrs, name) {\n    var method_type;\n    if (_.startsWith(name, '$')) {\n      throw new Error('Method names cannot start with $');\n    }\n    if (attrs.requestStream) {\n      if (attrs.responseStream) {\n        method_type = 'bidi';\n      } else {\n        method_type = 'client_stream';\n      }\n    } else {\n      if (attrs.responseStream) {\n        method_type = 'server_stream';\n      } else {\n        method_type = 'unary';\n      }\n    }\n    var serialize = attrs.requestSerialize;\n    var deserialize = attrs.responseDeserialize;\n    var method_func = requester_makers[method_type](\n        attrs.path, serialize, deserialize);\n    if (class_options.deprecatedArgumentOrder) {\n      Client.prototype[name] = deprecated_request_wrap(method_func);\n    } else {\n      Client.prototype[name] = method_func;\n    }\n    // Associate all provided attributes with the method\n    _.assign(Client.prototype[name], attrs);\n  });\n\n  return Client;\n};\n\n/**\n * Return the underlying channel object for the specified client\n * @param {Client} client\n * @return {Channel} The channel\n */\nexports.getClientChannel = function(client) {\n  return client.$channel;\n};\n\n/**\n * Wait for the client to be ready. The callback will be called when the\n * client has successfully connected to the server, and it will be called\n * with an error if the attempt to connect to the server has unrecoverablly\n * failed or if the deadline expires. This function will make the channel\n * start connecting if it has not already done so.\n * @param {Client} client The client to wait on\n * @param {(Date|Number)} deadline When to stop waiting for a connection. Pass\n *     Infinity to wait forever.\n * @param {function(Error)} callback The callback to call when done attempting\n *     to connect.\n */\nexports.waitForClientReady = function(client, deadline, callback) {\n  var checkState = function(err) {\n    if (err) {\n      callback(new Error('Failed to connect before the deadline'));\n      return;\n    }\n    var new_state = client.$channel.getConnectivityState(true);\n    if (new_state === grpc.connectivityState.READY) {\n      callback();\n    } else if (new_state === grpc.connectivityState.FATAL_FAILURE) {\n      callback(new Error('Failed to connect to server'));\n    } else {\n      client.$channel.watchConnectivityState(new_state, deadline, checkState);\n    }\n  };\n  checkState();\n};\n\n/**\n * Creates a constructor for clients for the given service\n * @param {ProtoBuf.Reflect.Service} service The service to generate a client\n *     for\n * @param {Object=} options Options to apply to the client\n * @return {function(string, Object)} New client constructor\n */\nexports.makeProtobufClientConstructor =  function(service, options) {\n  var method_attrs = common.getProtobufServiceAttrs(service, options);\n  if (!options) {\n    options = {deprecatedArgumentOrder: false};\n  }\n  var Client = exports.makeClientConstructor(\n      method_attrs, common.fullyQualifiedName(service),\n      options);\n  Client.service = service;\n  Client.service.grpc_options = options;\n  return Client;\n};\n\n/**\n * Map of status code names to status codes\n */\nexports.status = grpc.status;\n\n/**\n * See docs for client.callError\n */\nexports.callError = grpc.callError;\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/src/node/src/grpc_extension.js":"/*\n *\n * Copyright 2016, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\nvar binary = require('node-pre-gyp/lib/pre-binding');\nvar path = require('path');\nvar binding_path =\n    binary.find(path.resolve(path.join(__dirname, '../../../package.json')));\nvar binding = require(binding_path);\n\nmodule.exports = binding;\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/node_modules/node-pre-gyp/lib/pre-binding.js":"\"use strict\";\n\nvar versioning = require('../lib/util/versioning.js');\nvar existsSync = require('fs').existsSync || require('path').existsSync;\nvar path = require('path');\n\nmodule.exports = exports;\n\nexports.usage = 'Finds the require path for the node-pre-gyp installed module';\n\nexports.validate = function(package_json) {\n    versioning.validate_config(package_json);\n};\n\nexports.find = function(package_json_path,opts) {\n   if (!existsSync(package_json_path)) {\n        throw new Error(\"package.json does not exist at \" + package_json_path);\n   }\n   var package_json = require(package_json_path);\n   versioning.validate_config(package_json);\n   opts = opts || {};\n   if (!opts.module_root) opts.module_root = path.dirname(package_json_path);\n   var meta = versioning.evaluate(package_json,opts);\n   return meta.module;\n};\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/node_modules/node-pre-gyp/lib/util/versioning.js":"\"use strict\";\n\nmodule.exports = exports;\n\nvar path = require('path');\nvar semver = require('semver');\nvar url = require('url');\n\nvar abi_crosswalk;\n\n// This is used for unit testing to provide a fake\n// ABI crosswalk that emulates one that is not updated\n// for the current version\nif (process.env.NODE_PRE_GYP_ABI_CROSSWALK) {\n    abi_crosswalk = require(process.env.NODE_PRE_GYP_ABI_CROSSWALK);\n} else {\n    abi_crosswalk = require('./abi_crosswalk.json');\n}\n\nfunction get_electron_abi(runtime, target_version) {\n    if (!runtime) {\n        throw new Error(\"get_electron_abi requires valid runtime arg\");\n    }\n    if (typeof target_version === 'undefined') {\n        // erroneous CLI call\n        throw new Error(\"Empty target version is not supported if electron is the target.\");\n    }\n    // Electron guarantees that patch version update won't break native modules.\n    var sem_ver = semver.parse(target_version);\n    return runtime + '-v' + sem_ver.major + '.' + sem_ver.minor;\n}\nmodule.exports.get_electron_abi = get_electron_abi;\n\nfunction get_node_webkit_abi(runtime, target_version) {\n    if (!runtime) {\n        throw new Error(\"get_node_webkit_abi requires valid runtime arg\");\n    }\n    if (typeof target_version === 'undefined') {\n        // erroneous CLI call\n        throw new Error(\"Empty target version is not supported if node-webkit is the target.\");\n    }\n    return runtime + '-v' + target_version;\n}\nmodule.exports.get_node_webkit_abi = get_node_webkit_abi;\n\nfunction get_node_abi(runtime, versions) {\n    if (!runtime) {\n        throw new Error(\"get_node_abi requires valid runtime arg\");\n    }\n    if (!versions) {\n        throw new Error(\"get_node_abi requires valid process.versions object\");\n    }\n    var sem_ver = semver.parse(versions.node);\n    if (sem_ver.major === 0 && sem_ver.minor % 2) { // odd series\n        // https://github.com/mapbox/node-pre-gyp/issues/124\n        return runtime+'-v'+versions.node;\n    } else {\n        // process.versions.modules added in >= v0.10.4 and v0.11.7\n        // https://github.com/joyent/node/commit/ccabd4a6fa8a6eb79d29bc3bbe9fe2b6531c2d8e\n        return versions.modules ? runtime+'-v' + (+versions.modules) :\n            'v8-' + versions.v8.split('.').slice(0,2).join('.');\n    }\n}\nmodule.exports.get_node_abi = get_node_abi;\n\nfunction get_runtime_abi(runtime, target_version) {\n    if (!runtime) {\n        throw new Error(\"get_runtime_abi requires valid runtime arg\");\n    }\n    if (runtime === 'node-webkit') {\n        return get_node_webkit_abi(runtime, target_version || process.versions['node-webkit']);\n    } else if (runtime === 'electron') {\n        return get_electron_abi(runtime, target_version || process.versions.electron);\n    } else {\n        if (runtime != 'node') {\n            throw new Error(\"Unknown Runtime: '\" + runtime + \"'\");\n        }\n        if (!target_version) {\n            return get_node_abi(runtime,process.versions);\n        } else {\n            var cross_obj;\n            // abi_crosswalk generated with ./scripts/abi_crosswalk.js\n            if (abi_crosswalk[target_version]) {\n                cross_obj = abi_crosswalk[target_version];\n            } else {\n                var target_parts = target_version.split('.').map(function(i) { return +i; });\n                if (target_parts.length != 3) { // parse failed\n                    throw new Error(\"Unknown target version: \" + target_version);\n                }\n                /*\n                    The below code tries to infer the last known ABI compatible version\n                    that we have recorded in the abi_crosswalk.json when an exact match\n                    is not possible. The reasons for this to exist are complicated:\n\n                       - We support passing --target to be able to allow developers to package binaries for versions of node\n                         that are not the same one as they are running. This might also be used in combination with the\n                         --target_arch or --target_platform flags to also package binaries for alternative platforms\n                       - When --target is passed we can't therefore determine the ABI (process.versions.modules) from the node\n                         version that is running in memory\n                       - So, therefore node-pre-gyp keeps an \"ABI crosswalk\" (lib/util/abi_crosswalk.json) to be able to look\n                         this info up for all versions\n                       - But we cannot easily predict what the future ABI will be for released versions\n                       - And node-pre-gyp needs to be a `bundledDependency` in apps that depend on it in order to work correctly\n                         by being fully available at install time.\n                       - So, the speed of node releases and the bundled nature of node-pre-gyp mean that a new node-pre-gyp release\n                         need to happen for every node.js/io.js/node-webkit/nw.js/atom-shell/etc release that might come online if\n                         you want the `--target` flag to keep working for the latest version\n                       - Which is impractical ^^\n                       - Hence the below code guesses about future ABI to make the need to update node-pre-gyp less demanding.\n\n                    In practice then you can have a dependency of your app like `node-sqlite3` that bundles a `node-pre-gyp` that\n                    only knows about node v0.10.33 in the `abi_crosswalk.json` but target node v0.10.34 (which is assumed to be\n                    ABI compatible with v0.10.33).\n\n                    TODO: use semver module instead of custom version parsing\n                */\n                var major = target_parts[0];\n                var minor = target_parts[1];\n                var patch = target_parts[2];\n                // io.js: yeah if node.js ever releases 1.x this will break\n                // but that is unlikely to happen: https://github.com/iojs/io.js/pull/253#issuecomment-69432616\n                if (major === 1) {\n                    // look for last release that is the same major version\n                    // e.g. we assume io.js 1.x is ABI compatible with >= 1.0.0\n                    while (true) {\n                        if (minor > 0) --minor;\n                        if (patch > 0) --patch;\n                        var new_iojs_target = '' + major + '.' + minor + '.' + patch;\n                        if (abi_crosswalk[new_iojs_target]) {\n                            cross_obj = abi_crosswalk[new_iojs_target];\n                            console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);\n                            console.log('Warning: but node-pre-gyp successfully choose ' + new_iojs_target + ' as ABI compatible target');\n                            break;\n                        }\n                        if (minor === 0 && patch === 0) {\n                            break;\n                        }\n                    }\n                } else if (major === 0) { // node.js\n                    if (target_parts[1] % 2 === 0) { // for stable/even node.js series\n                        // look for the last release that is the same minor release\n                        // e.g. we assume node 0.10.x is ABI compatible with >= 0.10.0\n                        while (--patch > 0) {\n                            var new_node_target = '' + major + '.' + minor + '.' + patch;\n                            if (abi_crosswalk[new_node_target]) {\n                                cross_obj = abi_crosswalk[new_node_target];\n                                console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);\n                                console.log('Warning: but node-pre-gyp successfully choose ' + new_node_target + ' as ABI compatible target');\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            if (!cross_obj) {\n                throw new Error(\"Unsupported target version: \" + target_version);\n            }\n            // emulate process.versions\n            var versions_obj = {\n                node: target_version,\n                v8: cross_obj.v8+'.0',\n                // abi_crosswalk uses 1 for node versions lacking process.versions.modules\n                // process.versions.modules added in >= v0.10.4 and v0.11.7\n                modules: cross_obj.node_abi > 1 ? cross_obj.node_abi : undefined\n            };\n            return get_node_abi(runtime, versions_obj);\n        }\n    }\n}\nmodule.exports.get_runtime_abi = get_runtime_abi;\n\nvar required_parameters = [\n    'module_name',\n    'module_path',\n    'host'\n];\n\nfunction validate_config(package_json) {\n    var msg = package_json.name + ' package.json is not node-pre-gyp ready:\\n';\n    var missing = [];\n    if (!package_json.main) {\n        missing.push('main');\n    }\n    if (!package_json.version) {\n        missing.push('version');\n    }\n    if (!package_json.name) {\n        missing.push('name');\n    }\n    if (!package_json.binary) {\n        missing.push('binary');\n    }\n    var o = package_json.binary;\n    required_parameters.forEach(function(p) {\n        if (missing.indexOf('binary') > -1) {\n            missing.pop('binary');\n        }\n        if (!o || o[p] === undefined) {\n            missing.push('binary.' + p);\n        }\n    });\n    if (missing.length >= 1) {\n        throw new Error(msg+\"package.json must declare these properties: \\n\" + missing.join('\\n'));\n    }\n    if (o) {\n        // enforce https over http\n        var protocol = url.parse(o.host).protocol;\n        if (protocol === 'http:') {\n            throw new Error(\"'host' protocol (\"+protocol+\") is invalid - only 'https:' is accepted\");\n        }\n    }\n}\n\nmodule.exports.validate_config = validate_config;\n\nfunction eval_template(template,opts) {\n    Object.keys(opts).forEach(function(key) {\n        var pattern = '{'+key+'}';\n        while (template.indexOf(pattern) > -1) {\n            template = template.replace(pattern,opts[key]);\n        }\n    });\n    return template;\n}\n\n// url.resolve needs single trailing slash\n// to behave correctly, otherwise a double slash\n// may end up in the url which breaks requests\n// and a lacking slash may not lead to proper joining\nfunction fix_slashes(pathname) {\n    if (pathname.slice(-1) != '/') {\n        return pathname + '/';\n    }\n    return pathname;\n}\n\n// remove double slashes\n// note: path.normalize will not work because\n// it will convert forward to back slashes\nfunction drop_double_slashes(pathname) {\n    return pathname.replace(/\\/\\//g,'/');\n}\n\nfunction get_process_runtime(versions) {\n    var runtime = 'node';\n    if (versions['node-webkit']) {\n        runtime = 'node-webkit';\n    } else if (versions.electron) {\n        runtime = 'electron';\n    }\n    return runtime;\n}\n\nmodule.exports.get_process_runtime = get_process_runtime;\n\nvar default_package_name = '{module_name}-v{version}-{node_abi}-{platform}-{arch}.tar.gz';\nvar default_remote_path = '';\n\nmodule.exports.evaluate = function(package_json,options) {\n    options = options || {};\n    validate_config(package_json);\n    var v = package_json.version;\n    var module_version = semver.parse(v);\n    var runtime = options.runtime || get_process_runtime(process.versions);\n    var opts = {\n        name: package_json.name,\n        configuration: Boolean(options.debug) ? 'Debug' : 'Release',\n        debug: options.debug,\n        module_name: package_json.binary.module_name,\n        version: module_version.version,\n        prerelease: module_version.prerelease.length ? module_version.prerelease.join('.') : '',\n        build: module_version.build.length ? module_version.build.join('.') : '',\n        major: module_version.major,\n        minor: module_version.minor,\n        patch: module_version.patch,\n        runtime: runtime,\n        node_abi: get_runtime_abi(runtime,options.target),\n        target: options.target || '',\n        platform: options.target_platform || process.platform,\n        target_platform: options.target_platform || process.platform,\n        arch: options.target_arch || process.arch,\n        target_arch: options.target_arch || process.arch,\n        module_main: package_json.main,\n        toolset : options.toolset || '' // address https://github.com/mapbox/node-pre-gyp/issues/119\n    };\n    // support host mirror with npm config `--{module_name}_binary_host_mirror`\n    // e.g.: https://github.com/node-inspector/v8-profiler/blob/master/package.json#L25\n    // > npm install v8-profiler --profiler_binary_host_mirror=https://npm.taobao.org/mirrors/node-inspector/\n    var host = process.env['npm_config_' + opts.module_name + '_binary_host_mirror'] || package_json.binary.host;\n    opts.host = fix_slashes(eval_template(host,opts));\n    opts.module_path = eval_template(package_json.binary.module_path,opts);\n    // now we resolve the module_path to ensure it is absolute so that binding.gyp variables work predictably\n    if (options.module_root) {\n        // resolve relative to known module root: works for pre-binding require\n        opts.module_path = path.join(options.module_root,opts.module_path);\n    } else {\n        // resolve relative to current working directory: works for node-pre-gyp commands\n        opts.module_path = path.resolve(opts.module_path);\n    }\n    opts.module = path.join(opts.module_path,opts.module_name + '.node');\n    opts.remote_path = package_json.binary.remote_path ? drop_double_slashes(fix_slashes(eval_template(package_json.binary.remote_path,opts))) : default_remote_path;\n    var package_name = package_json.binary.package_name ? package_json.binary.package_name : default_package_name;\n    opts.package_name = eval_template(package_name,opts);\n    opts.staged_tarball = path.join('build/stage',opts.remote_path,opts.package_name);\n    opts.hosted_path = url.resolve(opts.host,opts.remote_path);\n    opts.hosted_tarball = url.resolve(opts.hosted_path,opts.package_name);\n    return opts;\n};\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/node_modules/node-pre-gyp/node_modules/semver/semver.js":"exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return compare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/src/node/src/common.js":"/*\n *\n * Copyright 2015, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/**\n * This module contains functions that are common to client and server\n * code. None of them should be used directly by gRPC users.\n * @module\n */\n\n'use strict';\n\nvar _ = require('lodash');\n\n/**\n * Get a function that deserializes a specific type of protobuf.\n * @param {function()} cls The constructor of the message type to deserialize\n * @param {bool=} binaryAsBase64 Deserialize bytes fields as base64 strings\n *     instead of Buffers. Defaults to false\n * @param {bool=} longsAsStrings Deserialize long values as strings instead of\n *     objects. Defaults to true\n * @return {function(Buffer):cls} The deserialization function\n */\nexports.deserializeCls = function deserializeCls(cls, binaryAsBase64,\n                                                 longsAsStrings) {\n  if (binaryAsBase64 === undefined || binaryAsBase64 === null) {\n    binaryAsBase64 = false;\n  }\n  if (longsAsStrings === undefined || longsAsStrings === null) {\n    longsAsStrings = true;\n  }\n  /**\n   * Deserialize a buffer to a message object\n   * @param {Buffer} arg_buf The buffer to deserialize\n   * @return {cls} The resulting object\n   */\n  return function deserialize(arg_buf) {\n    // Convert to a native object with binary fields as Buffers (first argument)\n    // and longs as strings (second argument)\n    return cls.decode(arg_buf).toRaw(binaryAsBase64, longsAsStrings);\n  };\n};\n\nvar deserializeCls = exports.deserializeCls;\n\n/**\n * Get a function that serializes objects to a buffer by protobuf class.\n * @param {function()} Cls The constructor of the message type to serialize\n * @return {function(Cls):Buffer} The serialization function\n */\nexports.serializeCls = function serializeCls(Cls) {\n  /**\n   * Serialize an object to a Buffer\n   * @param {Object} arg The object to serialize\n   * @return {Buffer} The serialized object\n   */\n  return function serialize(arg) {\n    return new Buffer(new Cls(arg).encode().toBuffer());\n  };\n};\n\nvar serializeCls = exports.serializeCls;\n\n/**\n * Get the fully qualified (dotted) name of a ProtoBuf.Reflect value.\n * @param {ProtoBuf.Reflect.Namespace} value The value to get the name of\n * @return {string} The fully qualified name of the value\n */\nexports.fullyQualifiedName = function fullyQualifiedName(value) {\n  if (value === null || value === undefined) {\n    return '';\n  }\n  var name = value.name;\n  var parent_name = fullyQualifiedName(value.parent);\n  if (parent_name !== '') {\n    name = parent_name + '.' + name;\n  }\n  return name;\n};\n\nvar fullyQualifiedName = exports.fullyQualifiedName;\n\n/**\n * Wrap a function to pass null-like values through without calling it. If no\n * function is given, just uses the identity;\n * @param {?function} func The function to wrap\n * @return {function} The wrapped function\n */\nexports.wrapIgnoreNull = function wrapIgnoreNull(func) {\n  if (!func) {\n    return _.identity;\n  }\n  return function(arg) {\n    if (arg === null || arg === undefined) {\n      return null;\n    }\n    return func(arg);\n  };\n};\n\n/**\n * Return a map from method names to method attributes for the service.\n * @param {ProtoBuf.Reflect.Service} service The service to get attributes for\n * @param {Object=} options Options to apply to these attributes\n * @return {Object} The attributes map\n */\nexports.getProtobufServiceAttrs = function getProtobufServiceAttrs(service,\n                                                                   options) {\n  var prefix = '/' + fullyQualifiedName(service) + '/';\n  var binaryAsBase64, longsAsStrings;\n  if (options) {\n    binaryAsBase64 = options.binaryAsBase64;\n    longsAsStrings = options.longsAsStrings;\n  }\n  /* This slightly awkward construction is used to make sure we only use\n     lodash@3.10.1-compatible functions. A previous version used\n     _.fromPairs, which would be cleaner, but was introduced in lodash\n     version 4 */\n  return _.zipObject(_.map(service.children, function(method) {\n    return _.camelCase(method.name);\n  }), _.map(service.children, function(method) {\n    return {\n      originalName: method.name,\n      path: prefix + method.name,\n      requestStream: method.requestStream,\n      responseStream: method.responseStream,\n      requestType: method.resolvedRequestType,\n      responseType: method.resolvedResponseType,\n      requestSerialize: serializeCls(method.resolvedRequestType.build()),\n      requestDeserialize: deserializeCls(method.resolvedRequestType.build(),\n                                         binaryAsBase64, longsAsStrings),\n      responseSerialize: serializeCls(method.resolvedResponseType.build()),\n      responseDeserialize: deserializeCls(method.resolvedResponseType.build(),\n                                          binaryAsBase64, longsAsStrings)\n    };\n  }));\n};\n\n/**\n * The logger object for the gRPC module. Defaults to console.\n */\nexports.logger = console;\n\n/**\n * The current logging verbosity. 0 corresponds to logging everything\n */\nexports.logVerbosity = 0;\n\n/**\n * Log a message if the severity is at least as high as the current verbosity\n * @param {Number} severity A value of the grpc.logVerbosity map\n * @param {String} message The message to log\n */\nexports.log = function log(severity, message) {\n  if (severity >= exports.logVerbosity) {\n    exports.logger.error(message);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/src/node/src/metadata.js":"/*\n *\n * Copyright 2015, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/**\n * Metadata module\n *\n * This module defines the Metadata class, which represents header and trailer\n * metadata for gRPC calls. Here is an example of how to use it:\n *\n * var metadata = new metadata_module.Metadata();\n * metadata.set('key1', 'value1');\n * metadata.add('key1', 'value2');\n * metadata.get('key1') // returns ['value1', 'value2']\n *\n * @module\n */\n\n'use strict';\n\nvar _ = require('lodash');\n\nvar grpc = require('./grpc_extension');\n\n/**\n * Class for storing metadata. Keys are normalized to lowercase ASCII.\n * @constructor\n */\nfunction Metadata() {\n  this._internal_repr = {};\n}\n\nfunction normalizeKey(key) {\n  key = key.toLowerCase();\n  if (grpc.metadataKeyIsLegal(key)) {\n    return key;\n  } else {\n    throw new Error('Metadata key\"' + key + '\" contains illegal characters');\n  }\n}\n\nfunction validate(key, value) {\n  if (grpc.metadataKeyIsBinary(key)) {\n    if (!(value instanceof Buffer)) {\n      throw new Error('keys that end with \\'-bin\\' must have Buffer values');\n    }\n  } else {\n    if (!_.isString(value)) {\n      throw new Error(\n          'keys that don\\'t end with \\'-bin\\' must have String values');\n    }\n    if (!grpc.metadataNonbinValueIsLegal(value)) {\n      throw new Error('Metadata string value \"' + value +\n                      '\" contains illegal characters');\n    }\n  }\n}\n\n/**\n * Sets the given value for the given key, replacing any other values associated\n * with that key. Normalizes the key.\n * @param {String} key The key to set\n * @param {String|Buffer} value The value to set. Must be a buffer if and only\n *     if the normalized key ends with '-bin'\n */\nMetadata.prototype.set = function(key, value) {\n  key = normalizeKey(key);\n  validate(key, value);\n  this._internal_repr[key] = [value];\n};\n\n/**\n * Adds the given value for the given key. Normalizes the key.\n * @param {String} key The key to add to.\n * @param {String|Buffer} value The value to add. Must be a buffer if and only\n *     if the normalized key ends with '-bin'\n */\nMetadata.prototype.add = function(key, value) {\n  key = normalizeKey(key);\n  validate(key, value);\n  if (!this._internal_repr[key]) {\n    this._internal_repr[key] = [];\n  }\n  this._internal_repr[key].push(value);\n};\n\n/**\n * Remove the given key and any associated values. Normalizes the key.\n * @param {String} key The key to remove\n */\nMetadata.prototype.remove = function(key) {\n  key = normalizeKey(key);\n  if (Object.prototype.hasOwnProperty.call(this._internal_repr, key)) {\n    delete this._internal_repr[key];\n  }\n};\n\n/**\n * Gets a list of all values associated with the key. Normalizes the key.\n * @param {String} key The key to get\n * @return {Array.<String|Buffer>} The values associated with that key\n */\nMetadata.prototype.get = function(key) {\n  key = normalizeKey(key);\n  if (Object.prototype.hasOwnProperty.call(this._internal_repr, key)) {\n    return this._internal_repr[key];\n  } else {\n    return [];\n  }\n};\n\n/**\n * Get a map of each key to a single associated value. This reflects the most\n * common way that people will want to see metadata.\n * @return {Object.<String,String|Buffer>} A key/value mapping of the metadata\n */\nMetadata.prototype.getMap = function() {\n  var result = {};\n  _.forOwn(this._internal_repr, function(values, key) {\n    if(values.length > 0) {\n      result[key] = values[0];\n    }\n  });\n  return result;\n};\n\n/**\n * Clone the metadata object.\n * @return {Metadata} The new cloned object\n */\nMetadata.prototype.clone = function() {\n  var copy = new Metadata();\n  _.forOwn(this._internal_repr, function(value, key) {\n    copy._internal_repr[key] = _.clone(value);\n  });\n  return copy;\n};\n\n/**\n * Gets the metadata in the format used by interal code. Intended for internal\n * use only. API stability is not guaranteed.\n * @private\n * @return {Object.<String, Array.<String|Buffer>>} The metadata\n */\nMetadata.prototype._getCoreRepresentation = function() {\n  return this._internal_repr;\n};\n\n/**\n * Creates a Metadata object from a metadata map in the internal format.\n * Intended for internal use only. API stability is not guaranteed.\n * @private\n * @param {Object.<String, Array.<String|Buffer>>} The metadata\n * @return {Metadata} The new Metadata object\n */\nMetadata._fromCoreRepresentation = function(metadata) {\n  var newMetadata = new Metadata();\n  if (metadata) {\n    _.forOwn(metadata, function(value, key) {\n      newMetadata._internal_repr[key] = _.clone(value);\n    });\n  }\n  return newMetadata;\n};\n\nmodule.exports = Metadata;\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/src/node/src/server.js":"/*\n *\n * Copyright 2015, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/**\n * Server module\n *\n * This module contains all the server code for Node gRPC: both the Server\n * class itself and the method handler code for all types of methods.\n *\n * For example, to create a Server, add a service, and start it:\n *\n * var server = new server_module.Server();\n * server.addProtoService(protobuf_service_descriptor, service_implementation);\n * server.bind('address:port', server_credential);\n * server.start();\n *\n * @module\n */\n\n'use strict';\n\nvar _ = require('lodash');\n\nvar grpc = require('./grpc_extension');\n\nvar common = require('./common');\n\nvar Metadata = require('./metadata');\n\nvar stream = require('stream');\n\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar Duplex = stream.Duplex;\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * Handle an error on a call by sending it as a status\n * @access private\n * @param {grpc.Call} call The call to send the error on\n * @param {Object} error The error object\n */\nfunction handleError(call, error) {\n  var statusMetadata = new Metadata();\n  var status = {\n    code: grpc.status.UNKNOWN,\n    details: 'Unknown Error'\n  };\n  if (error.hasOwnProperty('message')) {\n    status.details = error.message;\n  }\n  if (error.hasOwnProperty('code')) {\n    status.code = error.code;\n    if (error.hasOwnProperty('details')) {\n      status.details = error.details;\n    }\n  }\n  if (error.hasOwnProperty('metadata')) {\n    statusMetadata = error.metadata;\n  }\n  status.metadata = statusMetadata._getCoreRepresentation();\n  var error_batch = {};\n  if (!call.metadataSent) {\n    error_batch[grpc.opType.SEND_INITIAL_METADATA] =\n        (new Metadata())._getCoreRepresentation();\n  }\n  error_batch[grpc.opType.SEND_STATUS_FROM_SERVER] = status;\n  call.startBatch(error_batch, function(){});\n}\n\n/**\n * Send a response to a unary or client streaming call.\n * @access private\n * @param {grpc.Call} call The call to respond on\n * @param {*} value The value to respond with\n * @param {function(*):Buffer=} serialize Serialization function for the\n *     response\n * @param {Metadata=} metadata Optional trailing metadata to send with status\n * @param {number=} flags Flags for modifying how the message is sent.\n *     Defaults to 0.\n */\nfunction sendUnaryResponse(call, value, serialize, metadata, flags) {\n  var end_batch = {};\n  var statusMetadata = new Metadata();\n  var status = {\n    code: grpc.status.OK,\n    details: 'OK'\n  };\n  if (metadata) {\n    statusMetadata = metadata;\n  }\n  var message;\n  try {\n    message = serialize(value);\n  } catch (e) {\n    e.code = grpc.status.INTERNAL;\n    handleError(call, e);\n    return;\n  }\n  status.metadata = statusMetadata._getCoreRepresentation();\n  if (!call.metadataSent) {\n    end_batch[grpc.opType.SEND_INITIAL_METADATA] =\n        (new Metadata())._getCoreRepresentation();\n    call.metadataSent = true;\n  }\n  message.grpcWriteFlags = flags;\n  end_batch[grpc.opType.SEND_MESSAGE] = message;\n  end_batch[grpc.opType.SEND_STATUS_FROM_SERVER] = status;\n  call.startBatch(end_batch, function (){});\n}\n\n/**\n * Initialize a writable stream. This is used for both the writable and duplex\n * stream constructors.\n * @access private\n * @param {Writable} stream The stream to set up\n * @param {function(*):Buffer=} Serialization function for responses\n */\nfunction setUpWritable(stream, serialize) {\n  stream.finished = false;\n  stream.status = {\n    code : grpc.status.OK,\n    details : 'OK',\n    metadata : new Metadata()\n  };\n  stream.serialize = common.wrapIgnoreNull(serialize);\n  function sendStatus() {\n    var batch = {};\n    if (!stream.call.metadataSent) {\n      stream.call.metadataSent = true;\n      batch[grpc.opType.SEND_INITIAL_METADATA] =\n          (new Metadata())._getCoreRepresentation();\n    }\n\n    if (stream.status.metadata) {\n      stream.status.metadata = stream.status.metadata._getCoreRepresentation();\n    }\n    batch[grpc.opType.SEND_STATUS_FROM_SERVER] = stream.status;\n    stream.call.startBatch(batch, function(){});\n  }\n  stream.on('finish', sendStatus);\n  /**\n   * Set the pending status to a given error status. If the error does not have\n   * code or details properties, the code will be set to grpc.status.UNKNOWN\n   * and the details will be set to 'Unknown Error'.\n   * @param {Error} err The error object\n   */\n  function setStatus(err) {\n    var code = grpc.status.UNKNOWN;\n    var details = 'Unknown Error';\n    var metadata = new Metadata();\n    if (err.hasOwnProperty('message')) {\n      details = err.message;\n    }\n    if (err.hasOwnProperty('code')) {\n      code = err.code;\n      if (err.hasOwnProperty('details')) {\n        details = err.details;\n      }\n    }\n    if (err.hasOwnProperty('metadata')) {\n      metadata = err.metadata;\n    }\n    stream.status = {code: code, details: details, metadata: metadata};\n  }\n  /**\n   * Terminate the call. This includes indicating that reads are done, draining\n   * all pending writes, and sending the given error as a status\n   * @param {Error} err The error object\n   * @this GrpcServerStream\n   */\n  function terminateCall(err) {\n    // Drain readable data\n    setStatus(err);\n    stream.end();\n  }\n  stream.on('error', terminateCall);\n  /**\n   * Override of Writable#end method that allows for sending metadata with a\n   * success status.\n   * @param {Metadata=} metadata Metadata to send with the status\n   */\n  stream.end = function(metadata) {\n    if (metadata) {\n      stream.status.metadata = metadata;\n    }\n    Writable.prototype.end.call(this);\n  };\n}\n\n/**\n * Initialize a readable stream. This is used for both the readable and duplex\n * stream constructors.\n * @access private\n * @param {Readable} stream The stream to initialize\n * @param {function(Buffer):*=} deserialize Deserialization function for\n *     incoming data.\n */\nfunction setUpReadable(stream, deserialize) {\n  stream.deserialize = common.wrapIgnoreNull(deserialize);\n  stream.finished = false;\n  stream.reading = false;\n\n  stream.terminate = function() {\n    stream.finished = true;\n    stream.on('data', function() {});\n  };\n\n  stream.on('cancelled', function() {\n    stream.terminate();\n  });\n}\n\nutil.inherits(ServerUnaryCall, EventEmitter);\n\nfunction ServerUnaryCall(call) {\n  EventEmitter.call(this);\n  this.call = call;\n}\n\nutil.inherits(ServerWritableStream, Writable);\n\n/**\n * A stream that the server can write to. Used for calls that are streaming from\n * the server side.\n * @constructor\n * @param {grpc.Call} call The call object to send data with\n * @param {function(*):Buffer=} serialize Serialization function for writes\n */\nfunction ServerWritableStream(call, serialize) {\n  Writable.call(this, {objectMode: true});\n  this.call = call;\n\n  this.finished = false;\n  setUpWritable(this, serialize);\n}\n\n/**\n * Start writing a chunk of data. This is an implementation of a method required\n * for implementing stream.Writable.\n * @access private\n * @param {Buffer} chunk The chunk of data to write\n * @param {string} encoding Used to pass write flags\n * @param {function(Error=)} callback Callback to indicate that the write is\n *     complete\n */\nfunction _write(chunk, encoding, callback) {\n  /* jshint validthis: true */\n  var batch = {};\n  var self = this;\n  var message;\n  try {\n    message = this.serialize(chunk);\n  } catch (e) {\n    e.code = grpc.status.INTERNAL;\n    callback(e);\n    return;\n  }\n  if (!this.call.metadataSent) {\n    batch[grpc.opType.SEND_INITIAL_METADATA] =\n        (new Metadata())._getCoreRepresentation();\n    this.call.metadataSent = true;\n  }\n  if (_.isFinite(encoding)) {\n    /* Attach the encoding if it is a finite number. This is the closest we\n     * can get to checking that it is valid flags */\n    message.grpcWriteFlags = encoding;\n  }\n  batch[grpc.opType.SEND_MESSAGE] = message;\n  this.call.startBatch(batch, function(err, value) {\n    if (err) {\n      self.emit('error', err);\n      return;\n    }\n    callback();\n  });\n}\n\nServerWritableStream.prototype._write = _write;\n\nutil.inherits(ServerReadableStream, Readable);\n\n/**\n * A stream that the server can read from. Used for calls that are streaming\n * from the client side.\n * @constructor\n * @param {grpc.Call} call The call object to read data with\n * @param {function(Buffer):*=} deserialize Deserialization function for reads\n */\nfunction ServerReadableStream(call, deserialize) {\n  Readable.call(this, {objectMode: true});\n  this.call = call;\n  setUpReadable(this, deserialize);\n}\n\n/**\n * Start reading from the gRPC data source. This is an implementation of a\n * method required for implementing stream.Readable\n * @access private\n * @param {number} size Ignored\n */\nfunction _read(size) {\n  /* jshint validthis: true */\n  var self = this;\n  /**\n   * Callback to be called when a READ event is received. Pushes the data onto\n   * the read queue and starts reading again if applicable\n   * @param {grpc.Event} event READ event object\n   */\n  function readCallback(err, event) {\n    if (err) {\n      self.terminate();\n      return;\n    }\n    if (self.finished) {\n      self.push(null);\n      return;\n    }\n    var data = event.read;\n    var deserialized;\n    try {\n      deserialized = self.deserialize(data);\n    } catch (e) {\n      e.code = grpc.status.INTERNAL;\n      self.emit('error', e);\n      return;\n    }\n    if (self.push(deserialized) && data !== null) {\n      var read_batch = {};\n      read_batch[grpc.opType.RECV_MESSAGE] = true;\n      self.call.startBatch(read_batch, readCallback);\n    } else {\n      self.reading = false;\n    }\n  }\n  if (self.finished) {\n    self.push(null);\n  } else {\n    if (!self.reading) {\n      self.reading = true;\n      var batch = {};\n      batch[grpc.opType.RECV_MESSAGE] = true;\n      self.call.startBatch(batch, readCallback);\n    }\n  }\n}\n\nServerReadableStream.prototype._read = _read;\n\nutil.inherits(ServerDuplexStream, Duplex);\n\n/**\n * A stream that the server can read from or write to. Used for calls with\n * duplex streaming.\n * @constructor\n * @param {grpc.Call} call Call object to proxy\n * @param {function(*):Buffer=} serialize Serialization function for requests\n * @param {function(Buffer):*=} deserialize Deserialization function for\n *     responses\n */\nfunction ServerDuplexStream(call, serialize, deserialize) {\n  Duplex.call(this, {objectMode: true});\n  this.call = call;\n  setUpWritable(this, serialize);\n  setUpReadable(this, deserialize);\n}\n\nServerDuplexStream.prototype._read = _read;\nServerDuplexStream.prototype._write = _write;\n\n/**\n * Send the initial metadata for a writable stream.\n * @param {Metadata} responseMetadata Metadata to send\n */\nfunction sendMetadata(responseMetadata) {\n  /* jshint validthis: true */\n  var self = this;\n  if (!this.call.metadataSent) {\n    this.call.metadataSent = true;\n    var batch = {};\n    batch[grpc.opType.SEND_INITIAL_METADATA] =\n        responseMetadata._getCoreRepresentation();\n    this.call.startBatch(batch, function(err) {\n      if (err) {\n        self.emit('error', err);\n        return;\n      }\n    });\n  }\n}\n\nServerUnaryCall.prototype.sendMetadata = sendMetadata;\nServerWritableStream.prototype.sendMetadata = sendMetadata;\nServerReadableStream.prototype.sendMetadata = sendMetadata;\nServerDuplexStream.prototype.sendMetadata = sendMetadata;\n\n/**\n * Get the endpoint this call/stream is connected to.\n * @return {string} The URI of the endpoint\n */\nfunction getPeer() {\n  /* jshint validthis: true */\n  return this.call.getPeer();\n}\n\nServerUnaryCall.prototype.getPeer = getPeer;\nServerReadableStream.prototype.getPeer = getPeer;\nServerWritableStream.prototype.getPeer = getPeer;\nServerDuplexStream.prototype.getPeer = getPeer;\n\n/**\n * Wait for the client to close, then emit a cancelled event if the client\n * cancelled.\n */\nfunction waitForCancel() {\n  /* jshint validthis: true */\n  var self = this;\n  var cancel_batch = {};\n  cancel_batch[grpc.opType.RECV_CLOSE_ON_SERVER] = true;\n  self.call.startBatch(cancel_batch, function(err, result) {\n    if (err) {\n      self.emit('error', err);\n    }\n    if (result.cancelled) {\n      self.cancelled = true;\n      self.emit('cancelled');\n    }\n  });\n}\n\nServerUnaryCall.prototype.waitForCancel = waitForCancel;\nServerReadableStream.prototype.waitForCancel = waitForCancel;\nServerWritableStream.prototype.waitForCancel = waitForCancel;\nServerDuplexStream.prototype.waitForCancel = waitForCancel;\n\n/**\n * Fully handle a unary call\n * @access private\n * @param {grpc.Call} call The call to handle\n * @param {Object} handler Request handler object for the method that was called\n * @param {Metadata} metadata Metadata from the client\n */\nfunction handleUnary(call, handler, metadata) {\n  var emitter = new ServerUnaryCall(call);\n  emitter.on('error', function(error) {\n    handleError(call, error);\n  });\n  emitter.metadata = metadata;\n  emitter.waitForCancel();\n  var batch = {};\n  batch[grpc.opType.RECV_MESSAGE] = true;\n  call.startBatch(batch, function(err, result) {\n    if (err) {\n      handleError(call, err);\n      return;\n    }\n    try {\n      emitter.request = handler.deserialize(result.read);\n    } catch (e) {\n      e.code = grpc.status.INTERNAL;\n      handleError(call, e);\n      return;\n    }\n    if (emitter.cancelled) {\n      return;\n    }\n    handler.func(emitter, function sendUnaryData(err, value, trailer, flags) {\n      if (err) {\n        if (trailer) {\n          err.metadata = trailer;\n        }\n        handleError(call, err);\n      } else {\n        sendUnaryResponse(call, value, handler.serialize, trailer, flags);\n      }\n    });\n  });\n}\n\n/**\n * Fully handle a server streaming call\n * @access private\n * @param {grpc.Call} call The call to handle\n * @param {Object} handler Request handler object for the method that was called\n * @param {Metadata} metadata Metadata from the client\n */\nfunction handleServerStreaming(call, handler, metadata) {\n  var stream = new ServerWritableStream(call, handler.serialize);\n  stream.waitForCancel();\n  stream.metadata = metadata;\n  var batch = {};\n  batch[grpc.opType.RECV_MESSAGE] = true;\n  call.startBatch(batch, function(err, result) {\n    if (err) {\n      stream.emit('error', err);\n      return;\n    }\n    try {\n      stream.request = handler.deserialize(result.read);\n    } catch (e) {\n      e.code = grpc.status.INTERNAL;\n      stream.emit('error', e);\n      return;\n    }\n    handler.func(stream);\n  });\n}\n\n/**\n * Fully handle a client streaming call\n * @access private\n * @param {grpc.Call} call The call to handle\n * @param {Object} handler Request handler object for the method that was called\n * @param {Metadata} metadata Metadata from the client\n */\nfunction handleClientStreaming(call, handler, metadata) {\n  var stream = new ServerReadableStream(call, handler.deserialize);\n  stream.on('error', function(error) {\n    handleError(call, error);\n  });\n  stream.waitForCancel();\n  stream.metadata = metadata;\n  handler.func(stream, function(err, value, trailer, flags) {\n    stream.terminate();\n    if (err) {\n      if (trailer) {\n        err.metadata = trailer;\n      }\n      handleError(call, err);\n    } else {\n      sendUnaryResponse(call, value, handler.serialize, trailer, flags);\n    }\n  });\n}\n\n/**\n * Fully handle a bidirectional streaming call\n * @access private\n * @param {grpc.Call} call The call to handle\n * @param {Object} handler Request handler object for the method that was called\n * @param {Metadata} metadata Metadata from the client\n */\nfunction handleBidiStreaming(call, handler, metadata) {\n  var stream = new ServerDuplexStream(call, handler.serialize,\n                                      handler.deserialize);\n  stream.waitForCancel();\n  stream.metadata = metadata;\n  handler.func(stream);\n}\n\nvar streamHandlers = {\n  unary: handleUnary,\n  server_stream: handleServerStreaming,\n  client_stream: handleClientStreaming,\n  bidi: handleBidiStreaming\n};\n\n/**\n * Constructs a server object that stores request handlers and delegates\n * incoming requests to those handlers\n * @constructor\n * @param {Object=} options Options that should be passed to the internal server\n *     implementation\n */\nfunction Server(options) {\n  this.handlers = {};\n  var handlers = this.handlers;\n  var server = new grpc.Server(options);\n  this._server = server;\n  this.started = false;\n  /**\n   * Start the server and begin handling requests\n   * @this Server\n   */\n  this.start = function() {\n    if (this.started) {\n      throw new Error('Server is already running');\n    }\n    this.started = true;\n    server.start();\n    /**\n     * Handles the SERVER_RPC_NEW event. If there is a handler associated with\n     * the requested method, use that handler to respond to the request. Then\n     * wait for the next request\n     * @param {grpc.Event} event The event to handle with tag SERVER_RPC_NEW\n     */\n    function handleNewCall(err, event) {\n      if (err) {\n        return;\n      }\n      var details = event.new_call;\n      var call = details.call;\n      var method = details.method;\n      var metadata = Metadata._fromCoreRepresentation(details.metadata);\n      if (method === null) {\n        return;\n      }\n      server.requestCall(handleNewCall);\n      var handler;\n      if (handlers.hasOwnProperty(method)) {\n        handler = handlers[method];\n      } else {\n        var batch = {};\n        batch[grpc.opType.SEND_INITIAL_METADATA] =\n            (new Metadata())._getCoreRepresentation();\n        batch[grpc.opType.SEND_STATUS_FROM_SERVER] = {\n          code: grpc.status.UNIMPLEMENTED,\n          details: '',\n          metadata: {}\n        };\n        batch[grpc.opType.RECV_CLOSE_ON_SERVER] = true;\n        call.startBatch(batch, function() {});\n        return;\n      }\n      streamHandlers[handler.type](call, handler, metadata);\n    }\n    server.requestCall(handleNewCall);\n  };\n\n  /**\n   * Gracefully shuts down the server. The server will stop receiving new calls,\n   * and any pending calls will complete. The callback will be called when all\n   * pending calls have completed and the server is fully shut down. This method\n   * is idempotent with itself and forceShutdown.\n   * @param {function()} callback The shutdown complete callback\n   */\n  this.tryShutdown = function(callback) {\n    server.tryShutdown(callback);\n  };\n\n  /**\n   * Forcibly shuts down the server. The server will stop receiving new calls\n   * and cancel all pending calls. When it returns, the server has shut down.\n   * This method is idempotent with itself and tryShutdown, and it will trigger\n   * any outstanding tryShutdown callbacks.\n   */\n  this.forceShutdown = function() {\n    server.forceShutdown();\n  };\n}\n\n/**\n * Registers a handler to handle the named method. Fails if there already is\n * a handler for the given method. Returns true on success\n * @param {string} name The name of the method that the provided function should\n *     handle/respond to.\n * @param {function} handler Function that takes a stream of request values and\n *     returns a stream of response values\n * @param {function(*):Buffer} serialize Serialization function for responses\n * @param {function(Buffer):*} deserialize Deserialization function for requests\n * @param {string} type The streaming type of method that this handles\n * @return {boolean} True if the handler was set. False if a handler was already\n *     set for that name.\n */\nServer.prototype.register = function(name, handler, serialize, deserialize,\n                                     type) {\n  if (this.handlers.hasOwnProperty(name)) {\n    return false;\n  }\n  this.handlers[name] = {\n    func: handler,\n    serialize: serialize,\n    deserialize: deserialize,\n    type: type\n  };\n  return true;\n};\n\nvar unimplementedStatusResponse = {\n  code: grpc.status.UNIMPLEMENTED,\n  details: 'The server does not implement this method'\n};\n\nvar defaultHandler = {\n  unary: function(call, callback) {\n    callback(unimplementedStatusResponse);\n  },\n  client_stream: function(call, callback) {\n    callback(unimplementedStatusResponse);\n  },\n  server_stream: function(call) {\n    call.emit('error', unimplementedStatusResponse);\n  },\n  bidi: function(call) {\n    call.emit('error', unimplementedStatusResponse);\n  }\n};\n\n/**\n * Add a service to the server, with a corresponding implementation. If you are\n * generating this from a proto file, you should instead use\n * addProtoService.\n * @param {Object<String, *>} service The service descriptor, as\n *     {@link module:src/common.getProtobufServiceAttrs} returns\n * @param {Object<String, function>} implementation Map of method names to\n *     method implementation for the provided service.\n */\nServer.prototype.addService = function(service, implementation) {\n  if (!_.isObject(service) || !_.isObject(implementation)) {\n    throw new Error('addService requires two objects as arguments');\n  }\n  if (_.keys(service).length === 0) {\n    throw new Error('Cannot add an empty service to a server');\n  }\n  if (this.started) {\n    throw new Error('Can\\'t add a service to a started server.');\n  }\n  var self = this;\n  _.forOwn(service, function(attrs, name) {\n    var method_type;\n    if (attrs.requestStream) {\n      if (attrs.responseStream) {\n        method_type = 'bidi';\n      } else {\n        method_type = 'client_stream';\n      }\n    } else {\n      if (attrs.responseStream) {\n        method_type = 'server_stream';\n      } else {\n        method_type = 'unary';\n      }\n    }\n    var impl;\n    if (implementation[name] === undefined) {\n      /* Handle the case where the method is passed with the name exactly as\n         written in the proto file, instead of using JavaScript function\n         naming style */\n      if (implementation[attrs.originalName] === undefined) {\n        common.log(grpc.logVerbosity.ERROR, 'Method handler ' + name + ' for ' +\n            attrs.path + ' expected but not provided');\n        impl = defaultHandler[method_type];\n      } else {\n        impl = _.bind(implementation[attrs.originalName], implementation);\n      }\n    } else {\n      impl = _.bind(implementation[name], implementation);\n    }\n    var serialize = attrs.responseSerialize;\n    var deserialize = attrs.requestDeserialize;\n    var register_success = self.register(attrs.path, impl, serialize,\n                                         deserialize, method_type);\n    if (!register_success) {\n      throw new Error('Method handler for ' + attrs.path +\n          ' already provided.');\n    }\n  });\n};\n\n/**\n * Add a proto service to the server, with a corresponding implementation\n * @param {Protobuf.Reflect.Service} service The proto service descriptor\n * @param {Object<String, function>} implementation Map of method names to\n *     method implementation for the provided service.\n */\nServer.prototype.addProtoService = function(service, implementation) {\n  var options;\n  if (service.grpc_options) {\n    options = service.grpc_options;\n  }\n  this.addService(common.getProtobufServiceAttrs(service, options),\n                  implementation);\n};\n\n/**\n * Binds the server to the given port, with SSL enabled if creds is given\n * @param {string} port The port that the server should bind on, in the format\n *     \"address:port\"\n * @param {ServerCredentials=} creds Server credential object to be used for\n *     SSL. Pass an insecure credentials object for an insecure port.\n */\nServer.prototype.bind = function(port, creds) {\n  if (this.started) {\n    throw new Error('Can\\'t bind an already running server to an address');\n  }\n  return this._server.addHttp2Port(port, creds);\n};\n\n/**\n * @see module:src/server~Server\n */\nexports.Server = Server;\n","/home/travis/build/npmtest/node-npmtest-grpc/node_modules/grpc/src/node/src/credentials.js":"/*\n *\n * Copyright 2015, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/**\n * Credentials module\n *\n * This module contains factory methods for two different credential types:\n * CallCredentials and ChannelCredentials. ChannelCredentials are things like\n * SSL credentials that can be used to secure a connection, and are used to\n * construct a Client object. CallCredentials genrally modify metadata, so they\n * can be attached to an individual method call.\n *\n * CallCredentials can be composed with other CallCredentials to create\n * CallCredentials. ChannelCredentials can be composed with CallCredentials\n * to create ChannelCredentials. No combined credential can have more than\n * one ChannelCredentials.\n *\n * For example, to create a client secured with SSL that uses Google\n * default application credentials to authenticate:\n *\n * var channel_creds = credentials.createSsl(root_certs);\n * (new GoogleAuth()).getApplicationDefault(function(err, credential) {\n *   var call_creds = credentials.createFromGoogleCredential(credential);\n *   var combined_creds = credentials.combineChannelCredentials(\n *       channel_creds, call_creds);\n *   var client = new Client(address, combined_creds);\n * });\n *\n * @module\n */\n\n'use strict';\n\nvar grpc = require('./grpc_extension');\n\nvar CallCredentials = grpc.CallCredentials;\n\nvar ChannelCredentials = grpc.ChannelCredentials;\n\nvar Metadata = require('./metadata.js');\n\nvar common = require('./common.js');\n\nvar _ = require('lodash');\n\n/**\n * Create an SSL Credentials object. If using a client-side certificate, both\n * the second and third arguments must be passed.\n * @param {Buffer} root_certs The root certificate data\n * @param {Buffer=} private_key The client certificate private key, if\n *     applicable\n * @param {Buffer=} cert_chain The client certificate cert chain, if applicable\n * @return {ChannelCredentials} The SSL Credentials object\n */\nexports.createSsl = ChannelCredentials.createSsl;\n\n/**\n * Create a gRPC credentials object from a metadata generation function. This\n * function gets the service URL and a callback as parameters. The error\n * passed to the callback can optionally have a 'code' value attached to it,\n * which corresponds to a status code that this library uses.\n * @param {function(String, function(Error, Metadata))} metadata_generator The\n *     function that generates metadata\n * @return {CallCredentials} The credentials object\n */\nexports.createFromMetadataGenerator = function(metadata_generator) {\n  return CallCredentials.createFromPlugin(function(service_url, cb_data,\n                                                   callback) {\n    metadata_generator({service_url: service_url}, function(error, metadata) {\n      var code = grpc.status.OK;\n      var message = '';\n      if (error) {\n        message = error.message;\n        if (error.hasOwnProperty('code') && _.isFinite(error.code)) {\n          code = error.code;\n        } else {\n          code = grpc.status.UNAUTHENTICATED;\n        }\n        if (!metadata) {\n          metadata = new Metadata();\n        }\n      }\n      callback(code, message, metadata._getCoreRepresentation(), cb_data);\n    });\n  });\n};\n\n/**\n * Create a gRPC credential from a Google credential object.\n * @param {Object} google_credential The Google credential object to use\n * @return {CallCredentials} The resulting credentials object\n */\nexports.createFromGoogleCredential = function(google_credential) {\n  return exports.createFromMetadataGenerator(function(auth_context, callback) {\n    var service_url = auth_context.service_url;\n    google_credential.getRequestMetadata(service_url, function(err, header) {\n      if (err) {\n        common.log(grpc.logVerbosity.INFO, 'Auth error:' + err);\n        callback(err);\n        return;\n      }\n      var metadata = new Metadata();\n      metadata.add('authorization', header.Authorization);\n      callback(null, metadata);\n    });\n  });\n};\n\n/**\n * Combine a ChannelCredentials with any number of CallCredentials into a single\n * ChannelCredentials object.\n * @param {ChannelCredentials} channel_credential The ChannelCredentials to\n *     start with\n * @param {...CallCredentials} credentials The CallCredentials to compose\n * @return ChannelCredentials A credentials object that combines all of the\n *     input credentials\n */\nexports.combineChannelCredentials = function(channel_credential) {\n  var current = channel_credential;\n  for (var i = 1; i < arguments.length; i++) {\n    current = current.compose(arguments[i]);\n  }\n  return current;\n};\n\n/**\n * Combine any number of CallCredentials into a single CallCredentials object\n * @param {...CallCredentials} credentials the CallCredentials to compose\n * @return CallCredentials A credentials object that combines all of the input\n *     credentials\n */\nexports.combineCallCredentials = function() {\n  var current = arguments[0];\n  for (var i = 1; i < arguments.length; i++) {\n    current = current.compose(arguments[i]);\n  }\n  return current;\n};\n\n/**\n * Create an insecure credentials object. This is used to create a channel that\n * does not use SSL. This cannot be composed with anything.\n * @return {ChannelCredentials} The insecure credentials object\n */\nexports.createInsecure = ChannelCredentials.createInsecure;\n"}